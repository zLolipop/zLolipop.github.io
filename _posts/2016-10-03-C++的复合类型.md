---
title: "C++的复合类型"
date: 2016-10-03 10:16
categories: C/C++
---

复合类型(*compound type*)是基于其他类型定义的类型，C++中有两种非常常见的复合类型： 引用(*reference*)和指针(*pointer*)


--------------


# 引用

引用其实就是为对象起了另外的名字

{% highlight cpp %}

int ival = 1024;
int &refVal = ival;   //refVal指向ival
int &refVal2;         //报错： 引用必须被初始化

{% endhighlight %}

程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。因为无法令引用重新绑定另外一个对象，因此<font color="red"> 引用必须初始化 </font>。定义了一个引用后，
对其进行的所有操作都是在与之绑定的对象上进行的。

{% highlight cpp %}

refVal = 1;       //把2赋给refVal指向的对象
int ii = refVal;  //与 ii = ival等价

{% endhighlight %}

**Note**:引用只能绑定在对象上，而不能与 *字面值* 或某个 *表达式* 的计算结果绑定在一起 (其实 **常量引用** 是可以绑定到字面值和表达式的计算结果上的，只要该表达式的结果能够转换成引用的类型即可)。

{% highlight cpp %}

int &refVal4 = 10;  // 错误：引用类型的初始值是一个字面值
const int &refVal4 = 10; // 正确

double dval = 3.14；
int &refVal5 = dval; //错误： 此处引用类型的初始值必须是int型对象
const int &refVal5 = dval; // 正确

{% endhighlight %}

> 这个是引用的一个例外——初始化对const的引用(常量引用)——在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能 **转换成引用的类型即可** 。而不必与之绑定的类型严格匹配

> 上面的 **ri** 引用了一个 *int* 型的数， 对 **ri** 的操作应该是整数运算，但是 **dval** 是double类型的，因此，为了确保让 **ri** 绑定到一个整数， 编译器把上面的代码改成了：


{% highlight cpp %}

const int temp = dval;   // 由双精度浮点数生成一个临时的整型常量
const int &ri  = temp;    //让ri绑定这个临时变量

{% endhighlight %}

> 在这种情况下， **ri** 绑定了一个 **临时量** 对象，也就是编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。

> 当 **ri** 不是常量引用时，就允许对 **ri** 进行赋值， 这样就会改变所引用对象的值。但是注意此时绑定的对象是一个临时量而不是 **dval**, 既然程序员让 **ri**引用 **dval**，
> 肯定就是想通过 **ri** 来改变 **dval** 的值，此时就与程序员的意图背道而驰了。既然大家都不想把引用绑定到临时量上，那么 C++也就把这用行为归为非法。


---------------


# 指针

指针(pointer)是"指向(point to)" 另外一种类型的复合类型，本身就是一个对象。指针与引用类似，也实现了对其他对象的间接访问。这之间有者一些区别

||引用|指针|
|----|----|----|
|是否对象|否|是|
|必须初始化|是|否|
|是否能为空|否|是|

由于引用不是对象，没有实际地址，所以不能定义指向引用的指针。

## 指针值

指针的值应属于下列4中位置之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，上述情况之外的其他值。

> 试图拷贝或者以其他方式访问无效指针的值都将引发错误，编译器不负责检查此类错误。尽管第2和第3种形式的指针都是有效的，但是这些指针没有指向任何具体对象，
 所以试图访问此类指针对象(根本没有)的行为将不被允许。


## 空指针

空指针(null pointer)不指向任何对象：

{% highlight cpp %}

int *p1 = nullptr;  // C++11标准
int *p2 = 0;
// 首先要 #include cstdlib
int *p3 = NULL;

{% endhighlight %}

在新标准下， 现在的C++程序最好使用 *nullptr* , 同时尽量避免使用 *NULL*
把 int 变量直接赋给指针是错误的操作， 即使int变量的值恰好等于0 也不行。

```cpp
int  zero = 0;
int *p = zero  //不能把int变量直接赋给指针。
```

## void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址,一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是什么类型的对象并不了解。

```cpp
double obj = 3.14, *pd = &obj;
void *pv = &obj;    //obj可以是任意类型的的对象
pv = pd;   // pv可以存放任意类型的指针
```

void* 指针能做的事情有限： 拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void* 指针。不能直接操作void* 指针所指的对象，因为我们不知道这些对象到底是什么类型的，
也就无法确定能在这个对象上做那些操作。

----------------


# 复合类型的声明

变量的定义包括一个基本数据类型(base type)和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。即一条定义语句可以定义出不同的数据类型的变量。
其实类修饰符也是声明符的一个部分，详见下文。

## 定义多个变量

经常有一种观点认为，在定义语句中，类型修饰符(* 或 &) 作用与本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们把空格写在了修饰符和变量名中间，例如

```cpp
int* p;   // 合法但是很容易产生误导
```

我们说这样的写法，容易产生误导是因为int\* 放在一起好像是这条语句中所有变量共同的类型一样。其实，事实是基本数据类型是int而非 int\* . \* 仅仅只是修饰了p而已,
对该语句声明中的的其他变量，根本不起什么作用。

```cpp
int* p1, p2;  //p1是指向int的指针，p2是int
```

## 指向指针的引用

引用本身不是对象，所以不成定义指向引用的指针。但是指针是对象，所以可以定义指向指针的引用。

{% highlight cpp %}

int i = 42；
int *p;
int *&r = p;  // r是一个对指针p的引用

{% endhighlight %}

上面的代码，要理解r的类型，最简单的方式就是从右向左读r的定义。离变量名最近的符号对变量有最直接的影响，因此r是一个引用。