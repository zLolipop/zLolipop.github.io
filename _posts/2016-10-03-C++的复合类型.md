---
title: "C++的复合类型"
date: 2016-10-03 10:16
categories: C/C++
---

复合类型(*compound type*)是基于其他类型定义的类型，C++中有两种非常常见的复合类型： 引用(*reference*)和指针(*pointer*)


--------------


# 引用

引用其实就是为对象起了另外的名字

{% highlight cpp %}

int ival = 1024;
int &refVal = ival;   //refVal指向ival
int &refVal2;         //报错： 引用必须被初始化

{ % endhighlight % }

程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。因为无法令引用重新绑定另外一个对象，因此<font color="red"> 引用必须初始化 </font>。定义了一个引用后，
对其进行的所有操作都是在与之绑定的对象上进行的。

{% highlight cpp %}

refVal = 1;       //把2赋给refVal指向的对象
int ii = refVal;  //与 ii = ival等价

{ % endhighlight % }

**Note**:引用只能绑定在对象上，而不能与 *字面值* 或某个 *表达式* 的计算结果绑定在一起 (其实 **常量引用** 是可以绑定到字面值和表达式的计算结果上的，只要该表达式的结果能够转换成引用的类型即可)。

{% highlight cpp %}

int &refVal4 = 10;  // 错误：引用类型的初始值是一个字面值
const int &refVal4 = 10; // 正确

double dval = 3.14；
int &refVal5 = dval; //错误： 此处引用类型的初始值必须是int型对象
const int &refVal5 = dval; // 正确

{ % endhighlight % }

> 这个是引用的一个例外——初始化对const的引用(常量引用)——在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能 **转换成引用的类型即可** 。而不必与之绑定的类型严格匹配

> 上面的 **ri** 引用了一个 *int* 型的数， 对 **ri** 的操作应该是整数运算，但是 **dval** 是double类型的，因此，为了确保让 **ri** 绑定到一个整数， 编译器把上面的代码改成了：


{% highlight cpp %}

const int temp = dval;   // 由双精度浮点数生成一个临时的整型常量
const int &ri  = temp;    //让ri绑定这个临时变量

{ % endhighlight % }

> 在这种情况下， **ri** 绑定了一个 **临时量** 对象，也就是编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。

> 当 **ri** 不是常量引用时，就允许对 **ri** 进行赋值， 这样就会改变所引用对象的值。但是注意此时绑定的对象是一个临时量而不是 **dval**, 既然程序员让 **ri**引用 **dval**，
> 肯定就是想通过 **ri** 来改变 **dval** 的值。此时就与程序员的意图背道而驰了，既然大家都不想把引用绑定到临时量上，那么 C++也就把这用行为归为非法。




